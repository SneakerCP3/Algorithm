#### 贪心算法

贪心算法是指，在对问题求解时，总是做出在当前看来最好的选择。也就是说，不从整体最优上加以考虑，他所做出的实在某种意义上的局部最优解。

##### 应用一：找零问题

假设商店老板需要找零n元钱，钱币的面额有：100元、50元、20元、5元、1元，如何找零使得所需钱币的数量最少？

```python
# 零钱兑换问题
def change(t,n):
    '''
    :param t: 零钱的种类
    :param n: 需要找的零钱
    :return: 最小的纸币数
    '''
    m = [0 for _ in range(len(t))]
    for i,money in enumerate(t):
        m[i] = n // money          # 对应币值的钱有几张
        n = n % money
    return sum(m)
```

##### 应用二：背包问题（分数背包：可以拿走其中一部分，商品为金砂）

一个小偷走某个商店发现他有n个商品，第i个商品价值Vi元，重Wi千克。他希望拿走的商品价值尽量高，但他的背包最多容纳W千克的问题，则他应该拿走哪些商品？

```python
def fraction_backpack(goods,w):
    '''
    :param goods: 商品列表，包含价值与重量
    :param w: 背包可背的最大重量
    :return: 商品情况和总价值
    '''
    # 以单位重量的价值来排序,降序，很关键
    goods.sort(key=lambda x: x[0] / x[1], reverse=True)
    m = [0 for _ in range(len(goods))]           # 初始化一个可以拿的商品列表
    total_value = 0                              # 初始化总价值0
    
    for i,(value,weight) in enumerate(goods):
        if w >= weight:                          # 如果背包多
            m[i] = 1                             # 拿一件该产品
            w -= weight                          # 减去背包重量
            total_value += value
        else:
            m[i] = w / weight                    # 如果背包不够拿一件，只能拿一部分
            w = 0
            total_value += m[i] * value          # 总价值也打折
            break
    return m,total_value

if __name__ == '__main__':
    goods = [(60, 10), (120, 30), (100, 20)]   #每个商品元组表示（价格，重量）
    print(fraction_backpack(goods,50))
```

##### 应用三：最大字符串拼接问题

有n个非负整数，将其按照字符串拼接的方式拼接为一个整数，如何拼接可以使得得到的整数最大？

思路：将n个非负整数按照最高位的数字大小排列，然后利用贪心算法求解

要点：数字排序：首位越大越靠前，但是当字符串长度不等时排序较难，可通过对比x+y和y+x来判断

```python
def bubble_sort_str(li):
    '''
    冒泡法将数字排序
    :param li:
    :return:
    '''
    n = len(li)
    for i in range(n):
        for j in range(n-i-1):
        	# 关键点：如何判定排序条件
            if int(li[j] + li[j+1]) < int(li[j+1] + li[j]):  
                li[j],li[j+1] = li[j+1],li[j]
    return li

def number_join(li):
    li = list(map(str,li))   # 将列表转化成新列表，形成一个字符串
    bubble_sort_str(li)
    return ''.join(li)

if __name__ == '__main__':
    li = ['32','94','128','1286','6','71']
    print(number_join(li))

```

##### 应用四：活动选择问题

假设有n个活动，这些活动要占用同一片场地，而场地在某时刻只能供一个活动使用。

每个活动都有一个开始时间Si和结束时间Fi，表示活动在[Si，Fi）区间占用场地。

问：安排哪些活动能够使该场地举办的活动的个数最多？

贪心结论：最先结束的活动一定是最优解的一部分。（不解释）

```python
def activity_selection(activities):
    activities.sort(key=lambda x:x[1])  # 将活动按照结束时间的早晚排序
    res = [activities[0]]   # 返回的结果里面，至少有第一个活动（最早结束）

    # 按照结束时间往后找，查看是否跟前面的活动冲突
    for i in range(1,len(activities)):
        # 如果该活动的开始时间，大于已经举行活动中的最后一个活动的结束时间，则不冲突
        if activities[i][0] >= res[-1][1]: # 左闭后开
            res.append(activities[i])  	   # 将活动加入到结果中
    return res

if __name__ == '__main__':
    activities = [(1,4),(0,6),(3,5),(3,9),(5,7),(5,9),(6,10),(8,12),(8,11),(12,16),(2,14)]  # 元组代表活动的开始时间与结束时间
    print(activity_selection(activities))
```

